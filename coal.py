# -*- coding: utf-8 -*-
"""coal.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sGHkibAnpTkEwYyXzJ8KBVUB0k8rPF8g
"""

import time
from gurobipy import GRB, Model

# Data

# Supplier capacities (maximum supply each supplier can provide)
capacity_in_supplier = {'supplier1': 120, 'supplier2': 100, 'supplier3': 80}

# Shipping costs from suppliers to factories (per unit)
shipping_cost_from_supplier_to_factory = {
    ('supplier1', 'factory1'): 4,
    ('supplier1', 'factory2'): 6,
    ('supplier2', 'factory1'): 5,
    ('supplier2', 'factory2'): 3,
    ('supplier3', 'factory1'): 7,
    ('supplier3', 'factory2'): 4
}

# Production costs at factories for negative and positive products (per unit)
cost_negatif = {'factory1': 39.39, 'factory2': 39.39}
cost_pozitif = {'factory1': 39.39, 'factory2': 39.39}

# List of customers
customers = ['fiat_35_nc', 'isuzu_24v']

# Shipping costs from factories to customers (per unit)
shipping_cost_from_factory_to_customer = {
    ('factory1', 'fiat_35_nc'): 20,
    ('factory1', 'isuzu_24v'): 35,
    ('factory2', 'fiat_35_nc'): 25,
    ('factory2', 'isuzu_24v'): 30,
}

# Demand for negative and positive products per customer
negatif_needed_for_customer = {
    'fiat_35_nc': 50,
    'isuzu_24v': 40
}

pozitif_needed_for_customer = {
    'fiat_35_nc': 60,
    'isuzu_24v': 30
}

# Extract unique factories and suppliers from the data
factories = list(set(i[1] for i in shipping_cost_from_supplier_to_factory.keys()))
suppliers = list(set(i[0] for i in shipping_cost_from_supplier_to_factory.keys()))

# Create optimization model
model = Model("coal_distribution")

# Decision variables:
# x[i]: quantity shipped from supplier to factory
# y_negatif[j]: quantity of negative product shipped from factory to customer
# y_pozitif[j]: quantity of positive product shipped from factory to customer
x = model.addVars(shipping_cost_from_supplier_to_factory.keys(), vtype=GRB.INTEGER, name="x")
y_negatif = model.addVars(shipping_cost_from_factory_to_customer.keys(), vtype=GRB.INTEGER, name="y_negatif")
y_pozitif = model.addVars(shipping_cost_from_factory_to_customer.keys(), vtype=GRB.INTEGER, name="y_pozitif")

# Objective function:
# Minimize total cost including:
# - shipping costs from suppliers to factories
# - production costs of negative and positive products at factories
# - shipping costs from factories to customers
model.setObjective(
    sum(x[i] * shipping_cost_from_supplier_to_factory[i] for i in shipping_cost_from_supplier_to_factory.keys()) +
    sum(y_negatif[j] * cost_negatif[j[0]] + y_pozitif[j] * cost_pozitif[j[0]] for j in shipping_cost_from_factory_to_customer.keys()) +
    sum((y_negatif[j] + y_pozitif[j]) * shipping_cost_from_factory_to_customer[j] for j in shipping_cost_from_factory_to_customer.keys()),
    GRB.MINIMIZE
)

# Flow conservation constraints at each factory:
# Total quantity received from suppliers = total quantity sent to customers (negative + positive)
for f in factories:
    model.addConstr(
        sum(x[i] for i in shipping_cost_from_supplier_to_factory.keys() if i[1] == f) ==
        sum(y_negatif[j] + y_pozitif[j] for j in shipping_cost_from_factory_to_customer.keys() if j[0] == f),
        f"flow_{f}"
    )

# Supplier capacity constraints:
# Total quantity shipped from each supplier cannot exceed its capacity
for s in suppliers:
    model.addConstr(
        sum(x[i] for i in shipping_cost_from_supplier_to_factory.keys() if i[0] == s) <= capacity_in_supplier[s],
        f"supply_{s}"
    )

# Demand fulfillment constraints for each customer:
# The amount of negative and positive product received by each customer must meet or exceed demand
for c in customers:
    model.addConstr(
        sum(y_negatif[j] for j in shipping_cost_from_factory_to_customer.keys() if j[1] == c) >= negatif_needed_for_customer[c],
        f"negatif_demand_{c}"
    )
    model.addConstr(
        sum(y_pozitif[j] for j in shipping_cost_from_factory_to_customer.keys() if j[1] == c) >= pozitif_needed_for_customer[c],
        f"pozitif_demand_{c}"
    )

# Optimize the model
model.optimize()
m = model

# Update model and optimize again (optional)
m.update()
model.optimize()

print(time.ctime())
if m.status == GRB.OPTIMAL:
    print(f'Optimal total cost: {m.objVal}')
else:
    print("Optimal solution not found. Status code:", m.status)